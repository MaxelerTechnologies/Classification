#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "Maxfiles.h"
#include "MaxSLiCInterface.h"


#define S 400384    //Total elements in matrix
#define N 4         //Elements per row (vector)
#define P 100096    //Rows in the matrix
#define K 76000      //Input data points
#define R 128       //mapped Roms

void radiusCPU(float *a,float *b,float *c,float *f, int m,float *out)
{
float temp;

    //Iterate through each row to find Euclidean distances
	for(int j = 0 ; j < P; j++)
	{
    temp = 0;

        //Iterate through each element in each row
		for(int i = 0 ; i < N; i++)
		{
			 //Calculate Euclidean distance for each element in the row
			 temp = pow(abs(a[i + N*m] - b[i + j*N]),2);

			 //Add it to total distance for each data point, DO NOT TAKE SQUARE ROOT BECAUSE WE ARE COMPARING TO
			 //RADIUS SQUARED
			 c[j + P*m] = temp + c[j + P*m];

		//If input data is within the specified data center cluster, update output with the index of the data center cluster,
		//if the input data is not within the cluster, update output with -1
			 if((i == N-1) & (c[j + P*m] < f[j]))
				 out[j + P*m] = j;
			 else
				 out[j + P*m]= -1;
		}
	}
}

int main(void)
{

	srand(time(NULL));

	double clock_t,start_t1,start_t2,end_t1,end_t2,total_t1,total_t2;

	int sizeBytes =  sizeof(float);
	float *a = malloc(K*N*sizeBytes);            //Declare memory for input data points
	float *b = malloc(N*P*sizeBytes);            //Declare memory for data cluster matrix
	double** c = malloc (R* sizeof(double*));     //Declare memory for pointer to array of FMems
	float *f = malloc(P*sizeBytes);            //Declare memory for unformatted data point radii
	double** g = malloc (32* sizeof(double*));     //Declare memory for pointer to array of FMems FOR RADIUS
	float * h = malloc(P*sizeBytes);              //Declare memory for RADIUS
	float *out = malloc(K*P*sizeBytes);          //Declare memory for output of CPU code
	float *expected = malloc(P*K*sizeBytes);     //Declare memory for output of DFE
	float *z = malloc(K*P * sizeBytes);          //Declare memory for Euclidean distances

	//Declare individual FMems consisting of 3128 floats each for data matrix

	for(int i = 0 ; i < R ; i++){
		c[i] = malloc((S/R)*sizeBytes*2); //for size of double
	}

	//Declare individual FMems consisting of 3128 floats each for radii
	for(int i = 0 ; i < R/4 ; i++){
			g[i] = malloc((S/R)*sizeBytes*2); //for size of double
		}

	//Generate input data

	for(int i = 0; i < N*K; i++){
		a[i] = random() % 100;
	}

	for(int i = 0; i < S; i++){
		b[i] = random() % 100;
	}


   //calculate radius squared
	for(int i = 0; i < P; i++){
			f[i] = random() % 100;
			f[i] = (f[i])*(f[i]);
			h[i] = f[i];
	}

/*
printf("here1\n");
	//Initialize CPU output and Euclidean distances
	for(int i = 0 ; i < P*K; i++){
			z[i] = 0;
			out[i] = 0;
		}
printf("here2\n");
*/

    //Initialize FMems with contents of b, such that first and second elements of b are placed in the first FMem, third and
	//fourth elements b are placed in second FMem, fifth and sixth elements place in third FMem, etc.
	for(int i = 0 ; i < (S)/(R*2) ; i++){
		for(int r = 0 ; r < R ; r++){
				for(int j = 0 ; j < 2 ; j ++){
					c[r][i*2 + j] = b[j + 2*r + 2*R*i];
			    }
		}
	}

	//Same initialization method, except for the radii
	for( int i = 0 ; i < (S)/(R*2) ; i++){
		for(int r = 0 ; r < R/4 ; r++){
			for(int j = 0 ; j < 2 ; j++){
			g[r][i*2 + j] = h[j + 2*r + 2*(R/4)*i];
			}
		}
	}

	printf("%d input data points\n", K);
/*
	printf("Running on CPU.\n");

        start_t1 = clock();
        printf("Starting CPU program, start_t1 = %.3lf\n", start_t1);

	//Call CPU check code for each input data point
	for(int i = 0 ; i < K ; i++){
			radiusCPU(a,b,z,f,i,out);
		}

        end_t1 = clock();
        printf("End of CPU program, end_t1 = %.3lf\n", end_t1);
       total_t1 = (double)(end_t1 - start_t1)/ CLOCKS_PER_SEC;
*/
	//declare struct consisting of all elements to be passed to the DFE
		max_file_t * mf = radius_init();
		max_engine_t * me = max_load(mf,"*");
		radius_actions_t actions;

		actions.param_K = K;
		actions.param_N = N;
		actions.param_P = P;
		actions.param_R = R;
		actions.instream_a = a;
		actions.outstream_c = expected;

		//assign pointers to corresponding mappedRoms
		double ** ptr = (double**)&(actions.inmem_radiusKernel_mappedRom000);

		for(int i = 0 ; i< R ; i++){
			*ptr = c[i];
			ptr++;
		}

		double ** ptr2 = (double**)&(actions.inmem_radiusKernel_mappedRom128);

		for(int i = 0 ; i< R/4 ; i++){
			*ptr2 = g[i];
			ptr2++;
		}
        

		printf("Running on DFE.\n");

		start_t2 = clock();
		printf("Starting DFE, start_t2 = %.3lf\n", start_t2);

		radius_run(me, &actions);

		 end_t2 = clock();
		 printf("End of DFE program, end_t2 = %.3lf\n", end_t2);
	 	total_t2 = (double)(end_t2 - start_t2)/ CLOCKS_PER_SEC;
	 	printf("Total time taken by CPU: %.3lf, total time take by DFE: %.3lf\n",total_t1,total_t2);

		// Check CPU code output against DFE output
		for(int i = 0; i < K*P; ++i)
			if (out[i] != expected[i]) {
				printf("%d %.3lf %.3lf\n", i, out[i], expected[i]);
				return 1;
			}

		printf("Done.\n");
		max_unload(me);
		return 0;
	}
